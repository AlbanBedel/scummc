#
#  ScummC Makefile.target
#  Copyright (C) 2005-2006  Alban Bedel
# 
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

## This Makefile MUST be run from a target build directory

## Include the target specific config.mak 
include config.mak

## Verify that this target is for the current host.
ifneq ($(shell uname -n | cut -d . -f 1),$(HOST))
$(error "This build target is not for this host but for $(HOST).")
endif

## Include all the programs definitions
include $(SRCDIR)/Makefile.defs

##
## With release build we only log to build.log
## with debug build we also output the log head on stdout
## unless SHOW_WARNINGS explicitly enable/disable them
##
ifndef SHOW_WARNINGS
ifeq ($(DEBUG),yes)
SHOW_WARNINGS=yes
endif
endif

## We must do this awkward stuff because we need to return false
## at the end otherwise make will not break on errors.
ifeq ($(SHOW_WARNINGS),yes)
LOG=2> $@.build.log && { head $@.build.log ; cat $@.build.log >> build.log ; rm -f $@.build.log ; } || { head $@.build.log ; cat $@.build.log >> build.log ; rm -f $@.build.log ; false ; }
else
LOG=2>> build.log
endif

## Build progress messages go the log and stdout
## and we don't care of the return value so we can
## simply pipe.
MSGLOG=| tee -a build.log

## Put a header in the logs
$(shell echo " ==============================================================================" >> build.log)
$(shell echo " make $(MAKECMDGOALS) - $(TARGET) - `date`" >> build.log)
$(shell echo " ==============================================================================" >> build.log)
$(shell echo >> build.log)

##
## Verify that the lib defs are corrects
##
define CHECK_LIB_template
$(foreach src,$($(1)_SRCS),$(if $(find $(src),$(lib_srcs)),$(error "$(src) is present in several libs.")))
lib_srcs+=$($(1)_SRCS)
endef

lib_srcs=$($(firstword $(LIBS))_SRCS)
$(foreach lib,$(wordlist 2,$(words $(LIBS)),$(LIBS)),$(eval $(call CHECK_LIB_template,$(lib))))


##
## First we "detect" which libs are enabled
##

## Template to check if a lib needed by a prog is missing
define TEST_PROG_LIB_template
ifneq ($(HAVE_$(2)),yes)
$(1)_MISS+=$(2)
endif
endef

## Template to check that a prog have all libs it need
define TEST_PROG_template
$(foreach lib,$($(1)_LIBS),$(eval $(call TEST_PROG_LIB_template,$(1),$(lib))))
ifeq ($($(1)_MISS),)
DO_$(2)+=$(1)
else
DONT_ALL+=$(1)
endif
endef

## Template for a group (programs, utils, etc)
define GROUP_template

## Check all the prog in the group
$(foreach prog,$($(1)),$(eval $(call TEST_PROG_template,$(prog),$(1))))

ALL+=$($(1))
DO_ALL+=$(DO_$(1))

$(2)_DEPS=$(foreach prog,$(DO_$(1)),$$($(prog)_DEPS))
all_DEPS+=$$($(2)_DEPS)

$(2): $$(DO_$(1):%=%$(EXESUF))

PHONY_TARGETS+=$(2)
endef

$(foreach grp,$(GROUPS),$(eval $(call GROUP_template,$(grp),$(shell echo $(grp) | tr [A-Z] [a-z]))))

all: $(DO_ALL:%=%$(EXESUF))


## Template to execute a command and log it
define CMD_template
	@echo "$(1)" >> build.log
	@$(1) $(2)
	@echo
	@echo >> build.log
endef

## Template for a dependency generation target
define DEP_template
$(1): $(2)
	@echo "Generating $$@ for $(TARGET)" $(MSGLOG)
	$(call CMD_template,$(CC) -MM -MG $(CFLAGS) $(3) $$< -o $$@,$$(LOG))
endef

## Template for a source needing extra cflags
define C2O_template
$(1).o: $(SRCDIR)/$(1).c
	@echo "Compiling $$@ for $(TARGET)" $(MSGLOG)
	$(call CMD_template,$(CC) -c $(CFLAGS) $(2) -o $$@ $$<,$$(LOG))

$(call DEP_template,$(1).d,$(SRCDIR)/$(1).c,$(2))

endef

define LIB_template
ifdef HAVE_$(1)
$(foreach src,$($(1)_SRCS),$(call C2O_template,$(src:%.c=%),$($(1)_CFLAGS)))
endif
endef

## Generate the targets for the sources needing special cflags
$(foreach lib,$(LIBS),$(eval $(call LIB_template,$(lib))))


## Handle the sources generated by bison

%.tab.c: $(SRCDIR)/%.y
	@echo "Generating $@ for $(TARGET)"  $(MSGLOG)
	$(call CMD_template,$(BISON) $(BISONFLAGS) -b $(<:$(SRCDIR)/%.y=%) $<,$(LOG))

%.tab.h: %.tab.c ;

## Normal sources
%.o: $(SRCDIR)/%.c
	@echo "Compiling $@ for $(TARGET)" $(MSGLOG)
	$(call CMD_template,$(CC) -c $(CFLAGS) -o $@ $<,$(LOG))

## Generated sources
%.o: %.c
	@echo "Compiling $@ for $(TARGET)" $(MSGLOG)
	$(call CMD_template,$(CC) -c $(CFLAGS) -o $@ $<,$(LOG))

## Deps
$(eval $(call DEP_template,%.d,%.c))
$(eval $(call DEP_template,%.d,$(SRCDIR)/%.c))

## Template for a program target
define PROGRAM_template

$(1)_OBJS = $($(1)_SRCS:%.c=%.o)
$(1)_DEPS = $($(1)_SRCS:%.c=%.d)
$(1)_LDFLAGS = $(foreach lib,$($(1)_LIBS),$($(lib)_LDFLAGS)) \
		$(foreach lib,$($(1)_OPT_LIBS),$($(lib)_LDFLAGS))

## The current make have a bug with templates. It bork out with
## 'virtual memory exhausted' when a dependency list inside
## a template exceed a given size (about 200 chars on my sys).
## So we workaround it with this trick.
## The last target include all the rest so it will still do
## 'virtual memory exhausted' if we don't have enough "slots".
## The touch are needed to avoid useless re-link.
.$(1).o0: $$(wordlist 1,16,$$($(1)_OBJS))
	@touch .$(1).o0
.$(1).o1: $$(wordlist 17,32,$$($(1)_OBJS))
	@touch .$(1).o1
.$(1).o2: $$(wordlist 33,48,$$($(1)_OBJS))
	@touch .$(1).o2
.$(1).o3: $$(wordlist 49,64,$$($(1)_OBJS))
	@touch .$(1).o3
.$(1).o4: $$(wordlist 65,80,$$($(1)_OBJS))
	@touch .$(1).o4
.$(1).o5: $$(wordlist 81,$$(words $$($(1)_OBJS)),$$($(1)_OBJS))
	@touch .$(1).o5

#$(1)$(EXESUF): $$($(1)_OBJS)
$(1)$(EXESUF): .$(1).o0 .$(1).o1 .$(1).o2 .$(1).o3 .$(1).o4 .$(1).o5
	@echo "Linking $$@ for $(TARGET)"  $(MSGLOG)
	$(call CMD_template,$(CC) -o $$@ $$($(1)_OBJS) $(LDFLAGS) $$($(1)_LDFLAGS),$$(LOG))

## Some platform (win32) need a suffix on the binaries (.exe)
## So to allow the all_PROG targets to work we also define
## a target without suffix.
ifneq ($(EXESUF),)
PHONY_TARGETS+=$(1)
$(1): $(1)$(EXESUF)
endif

endef

## Generate the targets for the buildable programs
$(foreach prog,$(DO_ALL),$(eval $(call PROGRAM_template,$(prog))))

## Template for a program that can't be built
define PROGRAM_MISS_LIB_template
$(1)$(EXESUF):
	@echo "Some libs are missing to build $$@ for $(TARGET):" \
	 $(shell echo $($(1)_MISS) | tr [A-Z] [a-z])  $(MSGLOG)
	@echo
	@echo >> build.log

PHONY_TARGETS+=$(1)$(EXESUF)

ifneq ($(EXESUF),)
PHONY_TARGETS+=$(1)
$(1): $(1)$(EXESUF)
endif

endef

## Generate the targets for the unbuildable programs
$(foreach prog,$(DONT_ALL),$(eval $(call PROGRAM_MISS_LIB_template,$(prog))))

## We make a little target for this one
## as we need -DSCC_IMG_TEST
imgtest: $(SRCDIR)/scc_img.c scc_fd.o
	@echo "Linking $@ for $(TARGET)"  $(MSGLOG)
	$(call CMD_template,$(CC) $(CFLAGS) -DSCC_IMG_TEST  -o $@ $^,$(LOG))

## Testing
ifeq ($(CAN_TEST),yes)
define TEST_template
test_$(1): progs
	@echo "Testing $(1) for $(TARGET)"  $(MSGLOG)
	@$$(MAKE) -f $(SRCDIR)/examples/$(1)/Makefile SRCDIR=$(SRCDIR) clean 2> /dev/null >&2
	$(call CMD_template,$$(MAKE) -f $(SRCDIR)/examples/$(1)/Makefile SRCDIR=$(SRCDIR) test,$(LOG))

PHONY_TARGETS+= test_$(1)

endef
else
define TEST_template
test_$(1):
	@echo "Can't run test for $(TARGET)"  $(MSGLOG)
	
PHONY_TARGETS+= test_$(1)

endef
endif

$(foreach tst,$(TESTS),$(eval $(call TEST_template,$(tst))))

test: $(TESTS:%=test_%)

PHONY_TARGETS+= test

## Clean the log
cleanlog:
	@echo "Cleaning the build logs for $(TARGET)"
	@echo
	@rm -f build.log
## Clean the objects and libs
clean: cleanlog
	@echo "Cleaning the object files for $(TARGET)"
	@echo
	@rm -f *.o *.a .*.o[0-9]
## Also clean the generated sources and execs
cleangen: clean
	@echo "Cleaning the generated files for $(TARGET)"
	@echo
	@rm -f *.output *.tab.[ch] *_lex.c *.d

cleanbin: cleangen
	@echo "Cleaning the binaries for $(TARGET)"
	@echo
	@rm -f $(ALL:%=%$(EXESUF)) imgtest

## Also kill the config
distclean: cleanbin
	@echo "Cleaning the build config for $(TARGET)"
	@echo
	@rm -f Makefile.bak config.h config.mak


## Avoid useless rebuild of the generated sources.
## .SECONDARY is not enough to prevent rm after they are
## generated bcs of the deps include.
.PRECIOUS: %.tab.c %.tab.h  %.c %.h

.PHONY:                                            \
	$(PHONY_TARGETS)                           \
	all                                        \
	cleanlog                                   \
	clean                                      \
	cleangen                                   \
	cleanbin                                   \
	distclean                                  \

## Compute the deps we need for the goals
## When there is no goal we build the default: the first group
ifneq ($(MAKECMDGOALS),)
DEPS=$(sort $(foreach goal,$(MAKECMDGOALS),$($(goal)_DEPS)))
else
DEPS=$(sort $($(shell echo $(firstword $(GROUPS)) | tr [A-Z] [a-z])_DEPS))
endif

## Include the deps if there is some
ifneq ($(DEPS),)
-include $(DEPS)
endif

## Error out on any undefined target

%:
	$(error "Target $@ doesn't exist.")

