#
#  ScummC Makefile.target
#  Copyright (C) 2005-2006  Alban Bedel
# 
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

## This Makefile MUST be run from a target build directory

## Include the target specific config.mak 
include config.mak

## Verify that this target is for the current host.
ifneq ($(shell uname -n | cut -d . -f 1),$(HOST))
$(error "This build target is not for this host but for $(HOST).")
endif

## Include all the programs definitions
include $(SRCDIR)/Makefile.defs

##
## With release build we only log to build.log
## with debug build we also output the log head on stdout
## unless SHOW_WARNINGS explicitly enable/disable them
##
ifndef SHOW_WARNINGS
ifeq ($(DEBUG),yes)
SHOW_WARNINGS=yes
endif
endif

## We must do this awkward stuff because we need to return false
## at the end otherwise make will not break on errors.
ifeq ($(SHOW_WARNINGS),yes)
LOG=2> $@.build.log && { head $@.build.log ; cat $@.build.log >> build.log ; rm -f $@.build.log ; } || { head $@.build.log ; cat $@.build.log >> build.log ; rm -f $@.build.log ; false ; }
else
LOG=2>> build.log
endif

## Build progress messages go the log and stdout
## and we don't care of the return value so we can
## simply pipe.
MSGLOG=| tee -a build.log

## Put a header in the logs
$(shell echo " ==============================================================================" >> build.log)
$(shell echo " make $(MAKECMDGOALS) - $(TARGET) - `date`" >> build.log)
$(shell echo " ==============================================================================" >> build.log)
$(shell echo >> build.log)

##
## Verify that the lib defs are corrects
##
define CHECK_LIB_template
$(foreach src,$($(1)_SRCS),$(if $(find $(src),$(lib_srcs)),$(error "$(src) is present in several libs.")))
lib_srcs+=$($(1)_SRCS)
endef

lib_srcs=$($(firstword $(LIBS))_SRCS)
$(foreach lib,$(wordlist 2,$(words $(LIBS)),$(LIBS)),$(eval $(call CHECK_LIB_template,$(lib))))


##
## First we "detect" which libs are enabled
##

## Template to check if a lib needed by a prog is missing
define TEST_PROG_LIB_template
ifneq ($(HAVE_$(2)),yes)
$(1)_MISS+=$(2)
endif
endef

## Template to check that a prog have all libs it need
define TEST_PROG_template
$(foreach lib,$($(1)_LIBS),$(eval $(call TEST_PROG_LIB_template,$(1),$(lib))))
ifeq ($($(1)_MISS),)
DO_$(2)+=$(1)
else
DONT_ALL+=$(1)
endif
endef

## Template for a group (programs, utils, etc)
define GROUP_template

## Check all the prog in the group
$(foreach prog,$($(1)),$(eval $(call TEST_PROG_template,$(prog),$(1))))

ALL+=$($(1))
DO_ALL+=$(DO_$(1))

$(2)_DEPS=$(foreach prog,$(DO_$(1)),$$($(prog)_DEPS))
all_DEPS+=$$($(2)_DEPS)

$(2): $$(DO_$(1):%=%$(EXESUF))

PHONY_TARGETS+=$(2)
endef

$(foreach grp,$(GROUPS),$(eval $(call GROUP_template,$(grp),$(shell echo $(grp) | tr [A-Z] [a-z]))))

all: $(DO_ALL:%=%$(EXESUF))


## Template to execute a command and log it
define CMD_template
	@echo "$(1)" >> build.log
	@$(1) $(2)
	@echo
	@echo >> build.log
endef

## Template for a dependency generation target
define DEP_template
$(1): $(2)
	@echo "Generating $$@ for $(TARGET)" $(MSGLOG)
	$(call CMD_template,$(CC) -MM -MG $(CFLAGS) $(3) $$< -o $$@,$$(LOG))
endef

## Template for a source needing extra cflags
define C2O_template
$(1).o: $(SRCDIR)/$(1).c
	@echo "Compiling $$@ for $(TARGET)" $(MSGLOG)
	$(call CMD_template,$(CC) -c $(CFLAGS) $(2) -o $$@ $$<,$$(LOG))

$(call DEP_template,$(1).d,$(SRCDIR)/$(1).c,$(2))

endef

define LIB_template
ifdef HAVE_$(1)
$(foreach src,$($(1)_SRCS),$(call C2O_template,$(src:%.c=%),$($(1)_CFLAGS)))
endif
endef

## Generate the targets for the sources needing special cflags
$(foreach lib,$(LIBS),$(eval $(call LIB_template,$(lib))))


## Handle the sources generated by bison

%.tab.c: $(SRCDIR)/%.y
	@echo "Generating $@ for $(TARGET)" $(MSGLOG)
	$(call CMD_template,$(BISON) $(BISONFLAGS) -b $(<:$(SRCDIR)/%.y=%) $<,$(LOG))

%.tab.h: %.tab.c ;

## Generated help messages
ifneq ($(XSLTPROC),)
%_help.h: $(SRCDIR)/man/%.xml $(SRCDIR)/man/header.xslt
	@echo "Generating $@ for $(TARGET)"  $(MSGLOG)
	$(call CMD_template,$(XSLTPROC) $(SRCDIR)/man/header.xslt $< > $@,$(LOG))
else
%_help.h: $(SRCDIR)/man/%.xml $(SRCDIR)/man/header.xslt
	@echo "Generating dummy $@ for $(TARGET)"  $(MSGLOG)
	@echo $(MSGLOG)
	@echo '/* This file was generated, do not edit. */' > $@
	@echo 'static scc_help_t $*_help = {' >> $@
	@echo '  .name = "$*",' >> $@
	@echo '  .usage = "[OPTIONS]"' >> $@
	@echo '};' >> $@
endif

## Normal sources
%.o: $(SRCDIR)/%.c
	@echo "Compiling $@ for $(TARGET)" $(MSGLOG)
	$(call CMD_template,$(CC) -c $(CFLAGS) -o $@ $<,$(LOG))

## Generated sources
%.o: %.c
	@echo "Compiling $@ for $(TARGET)" $(MSGLOG)
	$(call CMD_template,$(CC) -c $(CFLAGS) -o $@ $<,$(LOG))

## Deps
$(eval $(call DEP_template,%.d,%.c))
$(eval $(call DEP_template,%.d,$(SRCDIR)/%.c))

## Template for a program target
define PROGRAM_template

$(1)_OBJS = $($(1)_SRCS:%.c=%.o)
$(1)_DEPS = $($(1)_SRCS:%.c=%.d)
$(1)_LDFLAGS = $(foreach lib,$($(1)_LIBS),$($(lib)_LDFLAGS)) \
		$(foreach lib,$($(1)_OPT_LIBS),$($(lib)_LDFLAGS))

## The current make have a bug with templates. It bork out with
## 'virtual memory exhausted' when a dependency list inside
## a template exceed a given size (about 200 chars on my sys).
## So we workaround it with this trick.
## The last target include all the rest so it will still do
## 'virtual memory exhausted' if we don't have enough "slots".
## The touch are needed to avoid useless re-link.
.$(1).o0: $$(wordlist 1,16,$$($(1)_OBJS))
	@touch .$(1).o0
.$(1).o1: $$(wordlist 17,32,$$($(1)_OBJS))
	@touch .$(1).o1
.$(1).o2: $$(wordlist 33,48,$$($(1)_OBJS))
	@touch .$(1).o2
.$(1).o3: $$(wordlist 49,64,$$($(1)_OBJS))
	@touch .$(1).o3
.$(1).o4: $$(wordlist 65,80,$$($(1)_OBJS))
	@touch .$(1).o4
.$(1).o5: $$(wordlist 81,$$(words $$($(1)_OBJS)),$$($(1)_OBJS))
	@touch .$(1).o5

#$(1)$(EXESUF): $$($(1)_OBJS)
$(1)$(EXESUF): .$(1).o0 .$(1).o1 .$(1).o2 .$(1).o3 .$(1).o4 .$(1).o5
	@echo "Linking $$@ for $(TARGET)"  $(MSGLOG)
	$(call CMD_template,$(CC) -o $$@ $$($(1)_OBJS) $(LDFLAGS) $$($(1)_LDFLAGS),$$(LOG))

## Some platform (win32) need a suffix on the binaries (.exe)
## So to allow the all_PROG targets to work we also define
## a target without suffix.
ifneq ($(EXESUF),)
PHONY_TARGETS+=$(1)
$(1): $(1)$(EXESUF)
endif

endef

## Generate the targets for the buildable programs
$(foreach prog,$(DO_ALL),$(eval $(call PROGRAM_template,$(prog))))

## Template for a program that can't be built
define PROGRAM_MISS_LIB_template
$(1)$(EXESUF):
	@echo "Some libs are missing to build $$@ for $(TARGET):" \
	 $(shell echo $($(1)_MISS) | tr [A-Z] [a-z])  $(MSGLOG)
	@echo
	@echo >> build.log

PHONY_TARGETS+=$(1)$(EXESUF)

ifneq ($(EXESUF),)
PHONY_TARGETS+=$(1)
$(1): $(1)$(EXESUF)
endif

endef

## Generate the targets for the unbuildable programs
$(foreach prog,$(DONT_ALL),$(eval $(call PROGRAM_MISS_LIB_template,$(prog))))

## We make a little target for this one
## as we need -DSCC_IMG_TEST
imgtest: $(SRCDIR)/scc_img.c scc_fd.o
	@echo "Linking $@ for $(TARGET)"  $(MSGLOG)
	$(call CMD_template,$(CC) $(CFLAGS) -DSCC_IMG_TEST  -o $@ $^,$(LOG))

## Testing
ifeq ($(CAN_TEST),yes)

TEST_PARAMS = -f $(SRCDIR)/examples/$(1)/Makefile \
              SRCDIR=$(SRCDIR) \
              MAK_DIR=$(SRCDIR)/examples \

define TEST_template
test_$(1): progs
	@echo "Testing $(1) for $(TARGET)"  $(MSGLOG)
	@$$(MAKE) -C $(SRCDIR)/examples/$(1) clean 2> /dev/null >&2
	@$$(MAKE) $(TEST_PARAMS) clean 2> /dev/null >&2
	$(call CMD_template,$$(MAKE) $(TEST_PARAMS) test,$(LOG))

PHONY_TARGETS+= test_$(1)

endef
else
define TEST_template
test_$(1):
	@echo "Can't run test for $(TARGET)"  $(MSGLOG)

PHONY_TARGETS+= test_$(1)

endef
endif

$(foreach tst,$(TESTS),$(eval $(call TEST_template,$(tst))))

test: $(TESTS:%=test_%)

PHONY_TARGETS+= test

## Distrib generation
DISTRIB  = scummc-$(VERSION)-$(shell echo $(TARGET) | cut -d - -f 1-2)

distrib-data: $(DO_ALL)
	@echo "Creating the distrib data for $(TARGET)"
	@echo
	@rm -rf $(DISTRIB)
	@mkdir $(DISTRIB)
	@cp $(SRCDIR)/README.md $(SRCDIR)/LICENSE $(DISTRIB)
	@mkdir $(DISTRIB)/bin
	@cp $(DO_ALL:%=%$(EXESUF)) $(DISTRIB)/bin
	@cp -r $(SRCDIR)/include $(DISTRIB)/include > /dev/null
	@cp -r $(SRCDIR)/examples $(DISTRIB)/examples > /dev/null
	@cp -r $(SRCDIR)/man $(DISTRIB)/man > /dev/null
	@rm $(DISTRIB)/examples/scummc-config.mak.sample
	@sed 's/^ *# *EXESUF *=.*/EXESUF = $(EXESUF)/' \
	  < $(SRCDIR)/examples/scummc-config.mak.sample \
	  > $(DISTRIB)/examples/scummc-config.mak
	@EXAMPLES=$$(echo $$(cd $(DISTRIB)/examples && find . -maxdepth 1 -type d | grep / | sed 's,\./,,')) ; \
	sed "s/^ *# *EXAMPLES *=.*/EXAMPLES = $$EXAMPLES/" \
	  < $(SRCDIR)/Makefile.distrib \
	  > $(DISTRIB)/Makefile

define DISTRIB_template
$(DISTRIB).$(1): distrib-data
	@echo "Creating $$@ for $(TARGET)"
	@echo
	@$(2) $$@ $(DISTRIB)

distrib.$(1): $(DISTRIB).$(1)

PHONY_TARGETS += distrib.$(1)

$(DISTRIB).$(1)_DEPS = $(all_DEPS)
distrib.$(1)_DEPS    = $(all_DEPS)

ALL_DISTRIB += distrib.$(1)
endef

$(eval $(call DISTRIB_template,tar.gz,tar zcf))
$(eval $(call DISTRIB_template,tar.bz2,tar jcf))
$(eval $(call DISTRIB_template,zip,zip -qr))

distrib: distrib.tar.gz
distribs: $(ALL_DISTRIB)

PHONY_TARGETS+= distrib-data    \
	        distrib         \
                distribs        \

distrib_DEPS     = $(all_DEPS)
distribs_DEPS    = $(all_DEPS)


## Clean the log
cleanlog:
	@echo "Cleaning the build logs for $(TARGET)"
	@echo
	@rm -f build.log
## Clean the objects and libs
clean: cleanlog
	@echo "Cleaning the object files for $(TARGET)"
	@echo
	@rm -f *.o *.a .*.o[0-9]
## Also clean the generated sources and execs
cleangen: clean
	@echo "Cleaning the generated files for $(TARGET)"
	@echo
	@rm -f *.output *.tab.[ch] *_lex.c *.d *_help.h

cleanbin: cleangen
	@echo "Cleaning the binaries for $(TARGET)"
	@echo
	@rm -f $(ALL:%=%$(EXESUF)) imgtest

cleandistrib:
	@echo "Cleaning the distrib for $(TARGET)"
	@echo
	@rm -rf $(DISTRIB) $(DISTRIB).*

## Also kill the config
distclean: cleanbin cleandistrib
	@echo "Cleaning the build config for $(TARGET)"
	@echo
	@rm -f Makefile.bak config.h config.mak


## Avoid useless rebuild of the generated sources.
## .SECONDARY is not enough to prevent rm after they are
## generated bcs of the deps include.
.PRECIOUS: %.tab.c %.tab.h  %.c %.h

.PHONY:                                            \
	$(PHONY_TARGETS)                           \
	all                                        \
	cleanlog                                   \
	clean                                      \
	cleangen                                   \
	cleanbin                                   \
	distclean                                  \

## Compute the deps we need for the goals
## When there is no goal we build the default: the first group
ifneq ($(MAKECMDGOALS),)
DEPS=$(sort $(foreach goal,$(MAKECMDGOALS),$($(goal)_DEPS)))
else
DEPS=$(sort $($(shell echo $(firstword $(GROUPS)) | tr [A-Z] [a-z])_DEPS))
endif

## Include the deps if there is some
ifneq ($(DEPS),)
-include $(DEPS)
endif

## Error out on any undefined target

%:
	$(error "Target $@ doesn't exist.")

